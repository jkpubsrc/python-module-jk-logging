Hierarchical Logging
====================

Log frameworks typically provide a flat structure for writing log messages: Typically each log message will provided line by line one after the other. This log framework does something different. It provides a way to hierarchically stucture your logs.

Each logger will provide a method named `descend(...)` which allows you to create a nested logger, this way descending within a logging hierarchy you create. The logger returned provides logging methods identical to all other loggers, but the log messages issued with the new logger are not provided on the root level as before, the new log messages issued will be associated to the node created by invoking `descend(...)`. This way you will be able to create a hierarchy, each descending-log event acting as a node in a tree.

Additionally a `descend(...)` method is provided in order to allow descending to a nested level of logging. As programs typically are
structured in a hierarchical way to mirror various levels of abstraction this structure can directly be mirrored during logging as well.
`descend(...)` will therefor provide a new logger instance that can be used in place of the parent logger.

Example
-------

What exactly is this useful for? Consider you have a complex task at hand. You solve this typically by providing some top level methods that invoke methods of a more detailed grade which in turn invoke methods of an even finer detail. Each method you create to help you in solving a specific problem will have a certain level of abstraction. Each nested method invoked will have a higher detail of abstraction, until - on the lowest end - you will have very basic operations. This is typical for implementing algorithms.

Now while descending in your program by invoking a lower level method you can invoke `descend(...)` on your logger. This way all new log messages will be a child of your higher level log entry. This way your log entries will better reflect your program structure and this way will be able to aid you much more if you need to do some debugging on your program.

Example:

```python
class MyClass(object):

	def doSomethingVeryDetailed(self, someArguments, log):
		log.notice(....)
		...
		log.notice(....)
		...
		return ....

	def doAComplexTask(self, someArgument, log):
		...
		log2 = log.descend("Now doing some low abstraction activity for: " + someArgument)
		self.doSomethingVeryDetailed(log2)
		...
```

And you could invoke that methods like this:

```python
myObj = MyClass()

for item in myListOfItems:
	log.info("Preparing next item...")
	....
	log2 = log.descend("Now dealing with item " + item.id)
	doAComplexTask(self, ...., log2)
	....
```

You will end up with a log hierarchy that looks somehow like this:

* INFO : Preparing next item...
* INFO : Now dealing with item xyz
  * ....
  * INFO : Now doing some low abstraction activity for: xyz
    * NOTICE : ....
    * ....
    * NOTICE : ....
    * ....
  * ....

Output like this can be accomplished by writing code like this:

```python
log2 = log.descend("Initializing ...")
log3 = log2.descend("Looking for settings file to load")
...
log3.debug("Checking: /usr/local/etc/jkbackup/backup.cfg")
...
log2.notice("Loading configuration file: /etc/jkbackup/backup.cfg")
...
```

To give you an idea how this looks in a real-world scenario here is a short section of a log output generated by an application that makes use of the hierarchical logging feature:

```text
[2017-07-14 21:43:37]       INFO:  Initializing ...
	[2017-07-14 21:43:37]     NOTICE:  Looking for the settings file to load
		[2017-07-14 21:43:37]      DEBUG:  Checking: /usr/local/etc/backup/backup.cfg
		[2017-07-14 21:43:37]      DEBUG:  Checking: /etc/backup/backup.cfg
		[2017-07-14 21:43:37]      DEBUG:  Found: /etc/backup/backup.cfg
	[2017-07-14 21:43:37]     NOTICE:  Loading configuration file: /etc/backup/backup.cfg
	[2017-07-14 21:43:37]     NOTICE:  Parsing configuration and performing basic initialization ...
		[2017-07-14 21:43:37]      DEBUG:  Instantiating logger ....
		[2017-07-14 21:43:37]      DEBUG:  Instantiating list of individual script commands ....
		[2017-07-14 21:43:37]      DEBUG:  Instantiating list of backup script definitions ....
		[2017-07-14 21:43:37]      DEBUG:  Instantiating local repository ....
		[2017-07-14 21:43:37]     NOTICE:  Local host name detected: nb-sirius
		[2017-07-14 21:43:37]     NOTICE:  Local IP address detected: 192.168.10.13
		[2017-07-14 21:43:37]       INFO:  Using backup ID: nb-sirius
		[2017-07-14 21:43:37]      DEBUG:  Instantiating remote repository ....
	[2017-07-14 21:43:37]     NOTICE:  Initialization successfully completed.
```

How such hierarchical output is managed
---------------------------------------

Of course output to console or files are linear by nature. That means they are not ideal to reflect such hierarchical structure. Therefor indentation is used to reflect the log hierarchy you created: Child log entries are indented to be clearly visible as being childs of their parent node. This is done in realtime which in this case means all log messages issued by your program are immediately formatted and written out.

It gets more interesting with some loggers such as `BufferLogger`. This logger will keep all log messages in memory throughout it's lifetime. Because of this no output will be generated right away, but if you forward the buffer to a logger later. If you forward this data to - for example - a file logger later, as recently as that moment the hierarchical data structure will be linearized and formatted with required indentation.

So if you decide about loggers to use for your application, always have in mind how the data is managed internally. Filter loggers as well as multiplexers don't store anything. File and console loggers format the data immediately and therefor require receiving log events in the correct order. Buffered loggers store the hierarchy internally and allow filtering, converting or forwarding later.

This feature is optional
------------------------

This feature is optional. If you don't use `descend(...)` you will not use this feature. Nevertheless in a lot of applications you will likely find this feature very helpful to structure your log data.






